/*
 *  ROM for the mythical Apple ][4
 *
 *  pomme -l Apple2four.lst -o Apple2four.rom Apple2four.pom 
 *
 */

const KBD         = $c000		// R last key pressed + 128
const KBDSTRB     = $c010		// RW keyboard strobe
const TAPEOUT     = $c020		// RW toggle caseette tape output
const SPKR        = $c030		// RW toggle speaker
const TXTCLR      = $c050		// RW display graphics
const TXTSET      = $c051		// RW display text
const MIXSET      = $c053		// RW display split screen
const TXTPAGE1    = $c054		// RW display page 1
const LORES       = $c056		// RW display lo-res graphics
const SETAN0      = $c058		// RW annunciator 0 off
const SETAN1      = $c05a		// RW annunciator 1 off
const CLRAN2      = $c05d		// RW annunciator 2 on
const CLRAN3      = $c05f		// RW annunciator 3 on
const TAPEIN      = $c060		// R cassete tape input
const PADDL0      = $c064		// R analog input 0
const PTRIG       = $c070		// RW analog input reset
const CLRROM      = $cfff		// disable slot C8 ROM
const RSTVECTOR   = $fffc  	// Apple ][ 6502 reset vector
const PWREDUP     = $03f4  	// Apple ][ stores #$A5 to make RST a soft reboot

global TXTPTR 		= @$FE.a16	// $FE-$FF is the address of the current line of text
global TXTROW 		= @$3FF			// $3FF is the current row on the text screen
global TXTPOS 		= @$3FE			// $3FE is the current position (column) in the text screen
global TXTBUFFER 	= @$200			// $200-$2FF holds the line of text being typed

global ARG0				= @$00

/*
 *  The code begins with a JMPs to the OS functions
 *  (TBD: change all but the first JMP to a table of vectors and add JSR ($aaaa) address mode)
 */
sub Start @$FF0000 {
	jmp Reset
	jmp ClearScreen
	jmp ScrollScreen
}

/*
 *  RST vector points here
 */
sub Reset @$FF0200 {
	cld
	ldx #$ff
	txs
	lda TXTSET
	lda TXTPAGE1
	lda SETAN0					; AN0 = TTL hi
	lda SETAN1					; AN1 = TTL hi
	lda CLRAN2					; AN2 = TTL lo
	lda CLRAN3					; AN3 = TTL lo
	lda CLRROM					; turn off extension ROM
	bit KBDSTRB					; clear keyboard
	ldx #0
	jsr ClearScreen			; clear the screen (x = row 0)
}

/*
 *  Print Apple ][4 at the top of the screen
 */
sub AppleII4 {
	ldx #0
 loop_AppleII4:
	lda Hello,x
	beq +done_AppleII4
	ora #$80
	sta $400,x
	inx
	bne -loop_AppleII4
 done_AppleII4:
}

/*
 *  Echo the keys as they are typed and store in @TXTBUFFER
 */
sub EchoKeys {
	lda #2
	sta @TXTROW							; Start at row 2
	lda #0
	sta @TXTPOS							; Start at position 0
	jsr ClearInputBuffer
 echo_loop:
	jsr ScreenBase					; Set the @TEXTPTR based on @TXTROW
	lda @TXTPOS
	bne +echo_read
 draw_prompt:
	ldy #0
	lda #':'
	sta (@TXTPTR),y
	iny
	sty @TXTPOS
 echo_read:
	bit KBD 								; check keyboard for next key
	bpl -echo_read
	lda KBD 								; get the key code from the keyboard
	bit KBDSTRB							; clear keyboard strobe (a.k.a. ack keyboard read)
	cmp #$8D								; 13 = CR ($80 | $0D in high ASCII)
	beq +echo_next_line
	cmp #$88								; 8 = BS ($80 | $08 in high ASCII)
	beq +echo_backspace
	cmp #$9B								; 27 = ESC ($80 | $1B in high ASCII)
	beq +echo_escape
	cmp #$99								; control character ($80 | $19 in high ASCII)
	bcc -echo_read
	ldy @TXTPOS
	cpy #40 								; ignore if >= column 40
	beq -echo_loop
	sta (@TXTPTR),y
	and #$7F								; store (low) ASCII in TEXT buffer
	dey
	sta @TXTBUFFER,y
	inc @TXTPOS							; next position
	bra -echo_loop
 echo_next_line:
	jsr NextLine
 echo_command:
	jsr CommandLine
	jsr ClearInputBuffer
	jmp echo_loop
 echo_backspace:
	lda @TXTPOS
	beq -echo_loop
	tay
	dey
	sty @TXTPOS
	lda #$A0								; High ASCII ' '
	sta (@TXTPTR),y
	jmp echo_loop
 echo_escape:
	ldx #2
	jsr ClearScreen					; clear the screen (x = row 2)
	lda #2
	sta @TXTROW							; reset to row 2
	lda #0
	sta @TXTPOS							; reset to position 0
	jmp echo_loop
}

/*
 *  Lookup and execute the typed command
 */
sub CommandLine {
 command_check_clear:
  lda.t #CMD_Clear
  sta.t @ARG0
	jsr CompareText
	beq +not_command_clear
	jsr DoClear
	rts.a24
 not_command_clear:
 command_check_memory:
  lda.t #CMD_Memory
  sta.t @ARG0
	jsr CompareText
	beq +not_command_memory
	lda #0
	jsr DoMemory
	rts.a24
 not_command_memory:
 command_check_reset:
  lda.t #CMD_Reset
  sta.t @ARG0
	jsr CompareText
	beq +not_command_reset
	jsr DoReset
	rts.a24
 not_command_reset:
 command_check_2plus:
  lda.t #CMD_2Plus
  sta.t @ARG0
	jsr CompareText
	beq +not_command_2plus
	jsr Do2Plus
	rts.a24
 not_command_2plus:
 command_check_c081:
  lda.t #CMD_C081
  sta.t @ARG0
	jsr CompareText
	beq +not_command_c081
	jsr DoC081
	rts.a24
 not_command_c081:
 command_check_c083:
  lda.t #CMD_C083
  sta.t @ARG0
	jsr CompareText
	beq +not_command_c083
	jsr DoC083
	rts.a24
 not_command_c083:
	rts.a24
}

/*
 *  Compare the text buffer with a string
 *  @ARG0.a24 points to the string
 */
sub CompareText {
	ldy #0
 compare_loop:
	lda @TXTBUFFER,y
 	a24
	cmp (@ARG0),y
	bne +compare_no_match
	iny
	cmp #0
	bne +compare_loop
 compare_match:
	lda (@ARG0),y
	bne +compare_no_match
	lda #$FF
	rts.a24
 compare_no_match:
	lda #0
	rts.a24
}

/*
 *  'clear'
 */
sub DoClear {
	ldx #2
	jsr ClearScreen
	lda #2
	sta @TXTROW						; Start at row 2
	lda #0
	sta @TXTPOS						; Start at position 0
	rts.a24
}

/*
 *  'memory'
 */
sub DoMemory {
	jsr NextLine
	lda #0
	jsr PrintHexByte
	lda #$AD
	jsr PrintChar
	jsr PrintSpace
	ldx #0
 loop_Memory:
	lda $00,x
	jsr PrintHexByte
	jsr PrintSpace
	inx
	cpx #8
	bne -loop_Memory
	jsr NextLine
	rts.a24
}

/*
 *  Print a hex byte
 *  A = value to print
 */
sub PrintHexByte {				
	pha
	lsr
	lsr
	lsr
	lsr
	jsr PrintHexDigit
	pla
	and #$0F
	jsr PrintHexDigit
	rts.a24
}

/*
 *  Print a hex digit
 *  A = nibble to print
 */
sub PrintHexDigit {
	cmp #10
	bcc +print_hex_digit_09
	clc
	adc #$B7
	bra +print_hex_digit
 print_hex_digit_09:
	adc #$B0
 print_hex_digit:
	ldy @TXTPOS
	sta (@TXTPTR),y
	inc @TXTPOS
	rts.a24
}

/*
 *  Print a character
 *  A = ASCII character
 */
sub PrintChar {
	ldy @TXTPOS
	sta (@TXTPTR),y
	inc @TXTPOS
	rts.a24
}

/*
 *  Print a space
 */
sub PrintSpace {
	lda #$A0
	ldy @TXTPOS
	sta (@TXTPTR),y
	inc @TXTPOS
	rts.a24
}

/*
 *  Restart at the beginning on the ROM
 *  @@@ Add a warm restart flag like on the ][+
 */
sub DoReset {
	nop											; @@@ THERE IS A BUG THAT FAILS TO COUNT THE LENGTH OF IF THERE IS JUST ONE OPCODE
	jmp Reset
}

/*
 *  Jump to the 6502 RST vector
 */
sub Do2Plus {
	sws											; Reset the stack width to 8-bits
	ldx #$ff 								; Reset the stack to $1FF
	txs
	lda #0
	sta PWREDUP 						; Make sure the Apple ][ ROM thinks this is a fresh reboot
	jmp (RSTVECTOR)					; Jump to the 6502 64K RST vector
}

/*
 *  Compute the TEXT screen pointer
 */
sub ScreenBase {
	X = @TXTROW							; X = @TXTROW
  xsl											; X = X * 2
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	rts.a24
}

/*
 *  Fill the TEXT screen with spaces from row X to row 23
 *  X = first row to start clearing
 */
sub ClearScreen {
  xsl											; X = X * 2
 loop_clear_line:
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	lda #$A0 								; $20 (space) | $80 (high ASCII)
	ldy #0
 loop_clear_char:
	sta (@TXTPTR),y
	iny
	cpy #40									; 40 columns wide
	bne -loop_clear_char
	inx
	inx
	cpx #48									; 24 rows (x2 bytes pre row pointer)
	bne -loop_clear_line
	rts.a24
}

; Check to see if the TEXT screen needs to be scrolled, and if so, scroll
sub NextLine {
	lda @TXTROW							; 24 rows tall (0-23)
	cmp #23
	beq +next_line_scroll
 next_line_next_row:
	inc @TXTROW							; Increment the current row
	jsr ScreenBase					; Update the @TXTPTR
	lda #0
	sta @TXTPOS							; Reset to position 0
	rts.a24
 next_line_scroll:
	ldx #2
	jsr ScrollScreen				; Scroll the screen, from row X=2
	lda #23
	sta @TXTROW							; Set to row 23
	lda #0
	sta @TXTPOS							; Reset to position 0
	rts.a24
}

/*
 *  Scroll the TEXT screen with spaces from row X to row 23
 *  X = first row to start clearing
 */
sub ScrollScreen {
  xsl											; X = X * 2
 loop_scroll_line:
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	lda.w TextScreenBase+2,x
	sta.w $00								; $00-$01 = address of the next line on the TEXT screen
	ldy #0
 loop_scroll_char:
	lda ($00),y
	sta (@TXTPTR),y
	iny
	cpy #40									; 40 columns
	bne -loop_scroll_char
	inx
	inx
	cpx #46									; Only 23 rows (46 = 23 x 2), as the the last line gets cleared
	bne -loop_scroll_line
 scroll_clear_last_line:
	lda.w TextScreenBase,x	; Lookup the address and copy to @TXTPTR
	sta.w @TXTPTR
	lda.w #$A0A0						; Two ' 's
	ldy #0
 loop_scroll_clear_line:
	sta.w (@TXTPTR),y
	iny
	iny
	cpy #40
	bne -loop_scroll_clear_line
 done_with_scroll:
	rts.a24
}

/*
 *  Clear the text input buffer (255 bytes, filled with zeros)
 */
sub ClearInputBuffer {
	lda #0
	ldx #$ff
 loop_clear_buffer:
	sta @TXTBUFFER,x
	dex
	bne -loop_clear_buffer
	sta $200
	rts.a24
}


/*
 *  'c081' @@@ DEBUGGING
 */
sub DoC081 {
	lda $C081
	lda $C081
	jsr NextLine
	lda #$aa
	sta $E000
	lda #$E0
	jsr PrintHexByte
	lda #0
	jsr PrintHexByte
	lda #$AD
	jsr PrintChar
	jsr PrintSpace
	ldx #0
 loop_c081:
	lda $E000,x
	jsr PrintHexByte
	jsr PrintSpace
	inx
	cpx #8
	bne -loop_c081
	jsr NextLine
	rts.a24
}

/*
 *  'c083' @@@ DEBUGGING
 */
sub DoC083 {
	lda $C083
	lda $C083
	jsr NextLine
	lda @TXTPOS
	sta $E000
	lda $04
	sta $E001
	lda #$E0
	jsr PrintHexByte
	lda #0
	jsr PrintHexByte
	lda #$AD
	jsr PrintChar
	jsr PrintSpace
	ldx #0
 loop_c083:
	lda $E000,x
	jsr PrintHexByte
	jsr PrintSpace
	inx
	cpx #8
	bne -loop_c083
	jsr NextLine
	rts.a24
}


/*
 *  The addresses of the 24 TEXT rows
 */
data TextScreenBase @$FF8000 word {
	$0400, $0480, $0500, $0580, $0600, $0680, $0700, $0780
	$0428, $04A8, $0528, $05A8, $0628, $06A8, $0728, $07A8
	$0450, $04D0, $0550, $05D0, $0650, $06D0, $0750, $07D0
}


/*
 *  The title of the reset screen
 */
data Hello string {
	"Apple ][4"
}

/*
 *  The list of commands
 */
data CMD_Clear string { "clear" }
data CMD_Memory string { "memory" }
data CMD_Reset string { "reset" }
data CMD_2Plus string { "2+" }
data CMD_C081 string { "c081" }
data CMD_C083 string { "c083" }

data CommandListLength byte { 6 }
data CommandList u24 {
	CMD_Clear
	CMD_Memory
	CMD_Reset
	CMD_2Plus
	CMD_C081
	CMD_C083
}

/*
 *  The 6502 vectors
 */
data Vectors @$FFFFF7 u24 {
	$000000 	; NMI
	$FF0000 	; RESET
	$000000 	; IRQ
}
