/*
 *  ROM for the mythical Apple ][4
 *
 *  Shell-level commands
 *
 */

/*
 *  '?' - List the commands
 */
sub DoHelp(NPRM %%0) {
	var I	= @$04						; loop variable
	var I6	= @$05						; I * 6
	var COL	= @$06						; column 0/12/24

	jsr NextLine

	lda.t #CommandListStr
	sta.t %%7
	jsr PrintString
	jsr NextLine

	@I = 1
	@COL = 0
	stz @TXTPGROWS
	DO {
		jsr PrintSpace

		lda @I							; X = @M$04 * 6 = (@M$04 * 4) + (@M$04 * 2)
		A <<= 2
		sta @I6
		lda @I
		A <<= 1
		clc
		adc @I6
		sta @I6
		tax

  		lda.t CommandList,X				; CommandList[X].string
  		sta.t %%7
		jsr PrintString

		lda @COL
		IF ==  {
			@COL = 1
			@TXTPOS = 12
		}
		ELSE {
			IF == 1 {
				@COL = 2
				@TXTPOS = 24
			}
			IF == 2 {
				@COL = 0
				lda #PAGINATE_LINES_PER_PAGE
				sta %%7
				jsr PaginateLine
			}
		}

		inc @I
		lda @I
	}
	WHILE (< N_COMMANDS)

	jsr NextLine

	RETURN
}


/*
 *  'ascii' - Show all the ASCII characters
 */
sub DoAscii(NPRM %%0) {
	lda @NPRM
	IF (==) {
		jmp asciiChart
	}
	ELSE {
		jmp asciiChar
	}
}
sub asciiChart(NPRM %%0) {
	var I	= @$00						; loop variable
	var J	= @$01						; I * 6
	var C	= @$02						; (@I << 4) + J

	jsr NextLine

	lda.t #ASCIIHeaderStr
	sta.t %%7
	jsr PrintString
	jsr NextLine

	lda.t #ASCIIDashesStr
	sta.t %%7
	jsr PrintString
	jsr NextLine

	stz @C
	FOR @I = 0 TO 15 {
		lda @I							; Print 0-F row value
		jsr PrintHexDigit
		lda #'-'H
		jsr PrintChar

		FOR @J = 0 TO 15 {
			lda @C						; A = (@I << 4) + J
			jsr PrintChar
			inc @C
		}

		jsr NextLine
	}

	lda.t #ASCIIDashesStr
	sta.t %%7
	jsr PrintString
	jsr NextLine

	RETURN
}
sub asciiChar(NPRM %%0, CMD %%0.1, CHARS %%0.4) {
	var I		= %R0.t
	var ASCII	= %R3

	stz @TXTPGROWS
	stz.t @I
	LOOP {
		ldx.t @CHARS					; First character in the @CHAR parameter
		ldy.t @I
		lda.a24 XY
		sta.t @ASCII
		IF (==) {						; Iterate until the end of the string of characters
			BREAK
		}

		lda @ASCII						; The typed character (in high ASCII)
		ora #$80
		jsr PrintChar
		lda #'-'H
		jsr PrintChar
		lda @ASCII
		ora #$80
		jsr PrintHexByte
		jsr PrintSpace
		jsr PrintSpace

		lda @ASCII						; Bottom quartile ASCII (invert)
		and #$3f
		jsr PrintChar
		lda #'-'H
		jsr PrintChar
		lda @ASCII
		and #$3f
		jsr PrintHexByte
		jsr PrintSpace

		lda @ASCII						; Second quartile ASCII (flashing)
		ora #$40
		and #$7f
		jsr PrintChar
		lda #'-'H
		jsr PrintChar
		lda @ASCII
		ora #$40
		and #$7f
		jsr PrintHexByte
		jsr PrintSpace

		lda @ASCII						; Third quartile ASCII (main block)
		ora #$80
		and #$Bf
		jsr PrintChar
		lda #'-'H
		jsr PrintChar
		lda @ASCII
		ora #$80
		and #$Bf
		jsr PrintHexByte
		jsr PrintSpace

		lda @ASCII						; Third quartile ASCII (lowercase)
		ora #$C0
		jsr PrintChar
		lda #'-'H
		jsr PrintChar
		lda @ASCII
		ora #$C0
		jsr PrintHexByte
		jsr PrintSpace

		inc @I
		lda #PAGINATE_LINES_PER_PAGE
		sta %%7
		jsr PaginateLine
		IF (!=) {
			BREAK
		}
	}
	lda #PAGINATE_LINES_PER_PAGE
	sta %%7
	jsr PaginateLine

	RETURN
}



/*
 *  'catalog' - Show the list of files on the harddisk or floppy
 */
sub DoCatalog(NPRM %%0, CMD %%0.1, DIRNAME %%0.4) {
	jsr NextLine

	lda @NPRM						; no dirname
	IF (< 1) {
		stz %%0.8					; Store a zero as an empty string
		lda.t #%%0.8				; Point @DIRNAME there
		sta.t @DIRNAME
	}

	lda.t #CatalogHeaderStr
	sta.t %%7
	jsr PrintString
	lda @NPRM
	IF (< 1) {
		jsr Disk4Name
		stx.t %%7
	}
	ELSE {
		lda #':'H
		jsr PrintChar
		lda.t @DIRNAME
		sta.t %%7
	}
	jsr PrintString
	jsr NextLine

	lda.t @DIRNAME
	sta.t %%6
	jsr Disk4CatalogStart
	IF (!=) {
		jsr Disk4PrintError
		RETURN
	}
	jsr NextLine

	LOOP {
		jsr Disk4CatalogNext
		IF (!=) {
			BREAK
		}
		stx.t %%7

		lda #2						; Print type (3 chars)
		sta @TXTPOS
		lda @DISK4_RAM
		jsr PrintChar
		lda @DISK4_RAM+1
		jsr PrintChar
		lda @DISK4_RAM+2
		jsr PrintChar

		lda #6						; Print size (3 numeric chars)
		sta @TXTPOS
		lda @DISK4_RAM+3
		jsr PrintChar
		lda @DISK4_RAM+4
		jsr PrintChar
		lda @DISK4_RAM+5
		jsr PrintChar

		lda #10						; Print filename
		sta @TXTPOS
		jsr PrintString

		jsr NextLine
	}
	jsr NextLine

	RETURN
}


/*
 *  'clear'
 */
sub DoClear(NPRM %%0) {
	lda @DISPMODE
	cmp #DISP_TEXT_1
	IF (==) {
		ldx #0
		jsr ClearScreen
		jsr AppleII4
		lda #2
		sta @TXTROW						; Start at row 2
		lda #0
		sta @TXTPOS						; Start at position 0
		RETURN
	}
	cmp #DISP_TEXT_2
	IF (==) {
		ldx #0
		jsr ClearScreen
		RETURN
	}
	cmp #DISP_LORES_1
	IF (==) {
		jsr ClearLores
		RETURN
	}
	cmp #DISP_LORES_2
	IF (==) {
		jsr ClearLores
		RETURN
	}
	cmp #DISP_HIRES_1
	IF (==) {
		jsr ClearHires
		RETURN
	}
	cmp #DISP_HIRES_2
	IF (==) {
		jsr ClearHires
		RETURN
	}
	RETURN
}


/*
 *  'echo'
 */
sub DoEcho(NPRM %%0, INPUT @$200) {
	lda #@INPUT
	sta.t %%7
	jsr PrintString
	jsr NextLine
	RETURN
}


/*
 *  'load' filename,address
 *
 */
sub DoLoad(NPRM %%0, CMD %%0.1, FILENAME %%0.4, ADDRESS %%0.7) {
	jsr NextLine

	lda @NPRM						; must specify a filename
	IF (< 1) {
		lda.t #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda @NPRM						; and an address
	IF (< 2) {
		lda.t #NoAddressErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	lda.t @ADDRESS					; parse the address
	sta.t %%7
	jsr ParseNumber
	sta.t @ADDRESS

	lda.t @FILENAME					; filename exists?
	IF (==) {
		lda #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	var FN = %R3.b
	sta.t %%6
	jsr Disk4Open
	IF (!=) {
		jsr Disk4PrintError
		RETURN
	}
	stx @FN
	stx @DISK4_PARAM0

	var R_IDX = %R4.t					; index of total bytes read across all loops
	var ACTUAL = %R7.w					; actual bytes read per Disk4Read
	var C_IDX = %R9.w					; bytes copied from the read buffer

	stz.t @R_IDX
	LOOP {
		jsr Disk4Read
		IF (== DISK4_END_OF_FILE) {		; Until EOF
			BREAK
		}
		lda.t @DISK4_RET0				; Or check for zero byes (to be safe)
		IF (==) {
			BREAK
		}
		sta.w @ACTUAL

		stz.w @C_IDX
		LOOP {
			ldx.w #@DISK4_RAM			; Load from $C800,Y
			ldy.w @C_IDX
			lda.a24 XY
			inc.t @C_IDX

			ldx.t @ADDRESS				; Store in @ADDRESS,Y
			ldy.t @R_IDX
			sta.a24 XY
			inc.t @R_IDX

			ldy.w @C_IDX				; Until @C_IDX == @ACTUAL
			cpy.w @ACTUAL
			IF (==) {
				BREAK
			}
		}
	}

	lda @FN
	jsr Disk4Close

	lda.t #LoadedStr
	sta.t %%7
	jsr PrintString

	lda.w @ACTUAL
	jsr PrintHexWord

	lda.t #LoadedBytesToStr
	sta.t %%7
	jsr PrintString

	lda.t @ADDRESS
	jsr PrintHex24

	jsr NextLine
	jsr NextLine

	RETURN
}


/*
 *  'view'
 */
sub DoView(NPRM %%0, CMD %%0.1, FILENAME %%0.4) {
	jsr NextLine

	lda @NPRM						; must specify a filename
	IF (< 1) {
		lda.t #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	var FN = %R3.b
	lda.t @FILENAME
	sta.t %%6
	jsr Disk4Open
	IF (!=) {
		jsr Disk4PrintError
		RETURN
	}
	stx @FN
	stx @DISK4_PARAM0

	var R_IDX 		= %R4.t				; index into the read buffer
	var ACTUAL 		= %R7.t				; actual bytes read per Disk4Read

	stz @TXTPGROWS
	LOOP {
		jsr Disk4Read
		IF (== DISK4_END_OF_FILE) {		; Until EOF
			BREAK
		}
		lda.t @DISK4_RET0				; Or check for zero byes (to be safe)
		IF (==) {
			BREAK
		}
		sta.t @ACTUAL

		stz.t @R_IDX
		LOOP {
			ldx.w #@DISK4_RAM			; Load from $C800,Y
			ldy.w @R_IDX
			lda.a24 XY
			IF (== 10) {
				lda #PAGINATE_LINES_PER_PAGE
				sta %%7
				jsr PaginateLine
				IF (!=) {
					BREAK
				}
			}
			IF (>= 32) {				; Only visible characters
				ldy @TXTPOS
				cpy #40					; The next pos is off the screen, so newline
				IF (>=) {
					lda #PAGINATE_LINES_PER_PAGE
					sta %%7
					jsr PaginateLine
					IF (!=) {
						bra +done
					}
					CONTINUE
				}
				ora #$80				; High ASCII
				sta (@TXTPTR),y
				inc @TXTPOS
			}

			inc.t @R_IDX
			lda.t @R_IDX
			cmp.t @ACTUAL
			IF (==) {
				BREAK
			}
		}
	}

  done:
	lda @FN
	jsr Disk4Close

	lda #PAGINATE_LINES_PER_PAGE
	sta %%7
	jsr PaginateLine

	RETURN
}


/*
 *  'store' - Store memory to a file
 */
sub DoStore(NPRM %%0, CMD %%0.1, FILENAME %%0.4, TYPE %%0.7, ADDRESS %%0.10, LENGTH %%0.13) {
	jsr NextLine

	lda @NPRM						; must specify a filename
	IF (< 1) {
		lda.t #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda @NPRM						; and an file type
	IF (< 2) {
		lda.t #NoFileTypeErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda @NPRM						; and an address
	IF (< 3) {
		lda.t #NoAddressErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda @NPRM						; and a length
	IF (< 4) {
		lda.t #NoLengthErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	lda.t @ADDRESS					; parse the address
	sta.t %%7
	jsr ParseNumber
	sta.t @ADDRESS

	ldx.t @LENGTH
	lda.a24 X
	cmp #'+'
	IF (==) {						; +length 
		inx.t						; address+1 to skip the '+'
		stx.t %%7
		jsr ParseNumber
		sta.t @LENGTH
	}
	ELSE {
		stx.t %%7
		jsr ParseNumber
		sta.t @LENGTH
		sec							; length = end - start
		sbc.t @ADDRESS
		sta.t @LENGTH
		IF (-) {
			lda.t #EndBeforeStartErrStr
			sta.t %%7
			jsr PrintError
			RETURN
		}
	}

	lda.t @FILENAME					; filename exists?
	IF (==) {
		lda #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	sta.t %%6
	lda.t @TYPE						; type exists?
	IF (==) {
		lda #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	var FN = %R3.b
	sta.t %%6.3
	jsr Disk4Create
	IF (!=) {
		jsr Disk4PrintError
		RETURN
	}
	stx @FN
	stx @DISK4_PARAM0

	var REMAINING = %R4.t				; bytes remaining to be written
	var W_IDX = %R7.t					; index of total bytes read across all loops
	var C_IDX = %R10.t					; bytes copied to the write buffer

	lda.t @LENGTH
	sta.t @REMAINING

	stz.t @W_IDX
	LOOP {
		lda.t @REMAINING				; Stop when all the bytes are written
		IF (==) {
			BREAK
		}

		jsr Disk4C800					; Enable writing to $C800
		stz.t @C_IDX
		LOOP {
			ldx.t @ADDRESS				; Load from @ADDRESS,Y
			ldy.t @W_IDX
			lda.a24 XY
			inc.t @W_IDX

			ldx.w #@DISK4_RAM			; Store in $C800,Y
			ldy.t @C_IDX
			sta.a24 XY
			inc.t @C_IDX

			lda.t @C_IDX				; Until @C_IDX == @ACTUAL
			cmp.t @REMAINING
			IF (==) {
				BREAK
			}
			cmp.t #1024					; Or up to 1024 bytes
			IF (==) {
				BREAK
			}
		}
		sta.t @DISK4_PARAM1				; Number of bytes

		lda.t @REMAINING				; @REMAINING -= @C_IDX
		sec
		sbc @C_IDX
		sta.w @REMAINING

		jsr Disk4Write
		IF (!=) {						; All errors are bad
			jsr Disk4PrintError
			BREAK
		}
	}

	lda @FN
	jsr Disk4Close
}


/*
 *  'peek' addr[,addr] or addr[,+length]
 */
sub DoPeek(NPRM %%0, CMD %%0.1, START_ADDR %%0.4, END_ADDR %%0.7) {
	var CUR_ADDR 	= %%0.252.t				; current address
	var ADDR 		= %R3.t

	lda @NPRM								; must specify a filename
	IF (< 1) {
		lda.t #NoAddressErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda.t @START_ADDR						; move the address to @STR
	sta.t %%7
	jsr ParseNumber
	and.t #$FFFFF0							; round down to multiple of 16
	sta.t @START_ADDR

	lda @NPRM								; and an address
	IF (>= 2) {
		ldx.t @END_ADDR
		lda.a24 X
		cmp #'+'
		IF (==) {							; +length 
			inx.t							; address+1 to skip the '+'
			stx.t %%7
			jsr ParseNumber
			tax.t							; @END = @START + length
			lda.t @START_ADDR
			adx.t
			sta.t @END_ADDR
		}
		ELSE {
			stx.t %%7
			jsr ParseNumber
			sta.t @END_ADDR
		}
	}
	ELSE {
		lda.t @START_ADDR
		clc
		adc.t #$40
		sta.t @END_ADDR
	}

	stz @TXTPGROWS
	lda.t @START_ADDR
	sta.t @CUR_ADDR
	LOOP {
		jsr Draw_Peek_Line
		lda #PAGINATE_LINES_PER_PAGE
		sta %%7
		jsr PaginateLine
		IF (!=) {
			BREAK
		}

		lda.t @CUR_ADDR
		clc
		adc.t #8
		sta.t @CUR_ADDR
		cmp.t @END_ADDR
		IF (>=) {
			BREAK
		}
	}

	lda #PAGINATE_LINES_PER_PAGE
	sta %%7
	jsr PaginateLine

	RETURN
}
sub Draw_Peek_Line(CUR_ADDR %%0.252.t) {
	var IDX 		= %R0.b
	var ADDR 		= %R3.t

	lda.t @CUR_ADDR
	sta.t @ADDR

	lda #'$'H						; $addr- xx xx xx xx xx xx xx xx ........
	jsr PrintChar
	lda.t @ADDR
	jsr PrintHex24
	lda #'-'H
	jsr PrintChar

	FOR @IDX = 0 to 7 {				; Print the value as $HH
		ldy @IDX
		lda.a24 (@ADDR),Y
		jsr PrintHexByte
		jsr PrintSpace
	}
	FOR @IDX = 0 to 7 {
		ldy @IDX
		lda.a24 (@ADDR),Y
		IF (< 128) {				; Print the (HIGH) ASCII equivalent of the value (except $00 = '.')
			IF (== 0) {
				lda #'.'H
			}
			ELSE {
				clc
				adc #128
			}
		}
		jsr PrintChar
	}

	RETURN
}


/*
 *  'poke' addr,value
 */
sub DoPoke(NPRM %%0, CMD %%0.1, ADDRESS %%0.4, VALUE %%0.7) {
	var CUR_ADDR 	= %%0.252.t			; current address

	lda @NPRM							; must specify a filename
	IF (< 1) {
		lda.t #NoAddressErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda.t @ADDRESS						; parse the address
	sta.t %%7
	jsr ParseNumber
	sta.t @ADDRESS

	lda @NPRM							; must specify a value
	IF (< 2) {
		lda.t #NoValueErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}
	lda.t @VALUE						; move the value to @STR
	sta.t %%7
	jsr ParseNumber
	sta.t @VALUE

	jsr NextLine

	ldx.t @ADDRESS
	lda.t @VALUE
	cmp.t #0xFF
	IF (<) {
		sta.a24.b X
		bra +skip
	}
	cmp.t #0xFFFF
	IF (<) { 							;; @@@ NEED ELSEIF
		sta.a24.w X
	}
	ELSE {
		sta.a24.t X
	}
  skip:

	lda.t @ADDRESS
	and.t #$FFFFF0
	sta.t @CUR_ADDR
	jsr Draw_Peek_Line
	jsr NextLine
	jsr NextLine

	RETURN
}



/*
 *  'run' filename
 *
 */
sub DoRun(NPRM %%0, CMD %%0.1, FILENAME %%0.4) {
	jsr NextLine

	lda @NPRM							; must specify a filename
	IF (< 1) {
		lda.t #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	lda.t @FILENAME						; filename exists?
	IF (==) {
		lda #NoFilenameErrStr
		sta.t %%7
		jsr PrintError
		RETURN
	}

	sta.t %%6
	jsr Disk4Exists
	IF (!=) {
		jsr Disk4PrintError
		RETURN
	}
	lda.t @DISK4_RAM					; The type is returned in $C800-$C802
	cmp.t #$ced5d2						; "NUR" = "RUN" loaded as one little-endian 24-bit value
	IF (!=) {
		lda.t #NotRUNFileError
		sta.t %%7
		jsr PrintError
		RETURN
	}

	var FN = %R3.b
	jsr Disk4Open
	IF (!=) {
		jsr Disk4PrintError
		RETURN
	}
	stx @FN
	sta @DISK4_PARAM0

	var R_IDX = %R4.t					; index of total bytes read across all loops
	var ACTUAL = %R7.w					; actual bytes read per Disk4Read
	var C_IDX = %R9.w					; bytes copied from the read buffer

	stz.t @R_IDX
	LOOP {
		jsr Disk4Read
		IF (== DISK4_END_OF_FILE) {		; Until EOF
			BREAK
		}
		lda.t @DISK4_RET0				; Or check for zero byes (to be safe)
		IF (==) {
			BREAK
		}
		sta.t @ACTUAL

		stz.w @C_IDX
		LOOP {
			ldx.w #@DISK4_RAM			; Load from $C800,Y
			ldy.w @C_IDX
			lda.a24 XY
			inc.t @C_IDX

			ldx.t #$10000				; Store in $10000 (after the first 64K ends)
			ldy.t @R_IDX
			sta.a24 XY
			inc.t @R_IDX

			ldy.w @C_IDX				; Until @C_IDX == @ACTUAL
			cpy.w @ACTUAL
			IF (==) {
				BREAK
			}
		}
	}

	lda @FN
	jsr Disk4Close

	ldx #1								; Shift the args run FILENAME [ARG...] --> FILENAME [ARG...]
	jsr shiftArgs
	jsr $10000							; Run the program

	lda.t #EndProgramStr				; Announce that the program has ended
	sta.t %%7
	jsr PrintError

	RETURN
}


/*
 *  'reset' - restarts at the beginning on the ROM
 *  @@@ Add a warm restart flag like on the ][+
 */
sub DoReset(NPRM %%0) {
	nop											; @@@ THERE IS A BUG THAT FAILS TO COUNT THE LENGTH OF IF THERE IS JUST ONE OPCODE
	jmp Reset
}


/*
 *  'text' - Switch to the TEXT screen (screen 1 or screen 2)
 */
sub DoText(NPRM %%0, CMD %%0.1, WHERE %%0.4) {
	lda @NPRM
	IF (< 1) {
		lda #DISP_TEXT_1
		jsr SetScreenMode
		RETURN
	}

	ldx.t @WHERE
	lda.a24 X
	cmp #'8'
	IF (==) {
		ldy #1
		lda.a24 XY
		cmp #'0'
		IF (==) {
			ldy #2
			lda.a24 XY
			IF (==) {
				lda #DISP_80COL_1
				jsr SetScreenMode
			}
		}
		lda.t #InvalidValue
		sta.t %%7
		jsr PrintError
		RETURN
	}
	cmp #'1'
	IF (==) {
		ldy #1
		lda.a24 XY
		IF (==) {
			lda #DISP_TEXT_1
			jsr SetScreenMode
			RETURN
		}
	}
	cmp #'2'
	IF (==) {
		ldy #1
		lda.a24 XY
		IF (==) {
			lda #DISP_TEXT_2
			jsr SetScreenMode
			RETURN
		}
	}

	lda.t #InvalidValue
	sta.t %%7
	jsr PrintError
	RETURN
}


/*
 *  'lores' - Switch to the LORES screen (screen 1 or screen 2)
 */
sub DoLores(NPRM %%0, CMD %%0.1, WHERE %%0.4) {
	lda @NPRM
	IF (< 1) {
		lda #DISP_LORES_2				; Default is page 2 (to not overlap the commands on TEXT page 1)
		jsr SetScreenMode
		RETURN
	}

	ldx.t @WHERE
	lda.a24 X
	cmp #'1'
	IF (==) {
		ldy #1
		lda.a24 XY
		IF (==) {
			lda #DISP_LORES_1
			jsr SetScreenMode
			RETURN
		}
	}
	cmp #'2'
	IF (==) {
		ldy #1
		lda.a24 XY
		IF (==) {
			lda #DISP_LORES_2
			jsr SetScreenMode
			RETURN
		}
	}

	lda.t #InvalidValue
	sta.t %%7
	jsr PrintError
	RETURN
}


/*
 *  'hires' - Switch to the HIRES screen (screen 1 or screen 2)
 */
sub DoHires(NPRM %%0, CMD %%0.1, WHERE %%0.4) {
	lda @NPRM
	IF (< 1) {
		lda #DISP_HIRES_1
		jsr SetScreenMode
		RETURN
	}

	ldx.t @WHERE
	lda.a24 X
	cmp #'1'
	IF (==) {
		ldy #1
		lda.a24 XY
		IF (==) {
			lda #DISP_HIRES_1
			jsr SetScreenMode
			RETURN
		}
	}
	cmp #'2'
	IF (==) {
		ldy #1
		lda.a24 XY
		IF (==) {
			lda #DISP_HIRES_2
			jsr SetScreenMode
			RETURN
		}
	}

	lda.t #InvalidValue
	sta.t %%7
	jsr PrintError
	RETURN
}


/*
 *  Jump to the 6502 RST vector
 */
sub Do2Plus(NPRM %%0) {
	sta LANGCLR					; disable the ][+ "upper" 16K (one write is sufficent)
	sws							; Reset the stack width to 8-bits
	ldx #$ff 					; Reset the stack to $1FF
	txs
	lda #0
	sta PWREDUP 				; Make sure the Apple ][ ROM thinks this is a fresh reboot
	jmp (RSTVECTOR)				; Jump to the 6502 64K RST vector
}


/*
 *  Shift all the args down X position(s)
 */
sub shiftArgs(NPRM %%0, SHIFT X) {
	var IDX = %R127
	stx @IDX
	var N3 = %R126
	var MOVETO = %R123.t

	; Shift one position at a time (which isn't efficient, but simpler)
	LOOP {
		lda @NPRM				; Topmost ARG is $D001 + (NPRM * 3)
		IF (==) {
			RETURN
		}
		dec						; Shift up to $D001 + (NPRM-1 * 3) = @MOVETO
		sta @N3
		clc
		adc @N3
		adc @N3
		adc.t #$D001
		sta.t @MOVETO

		ldx.t #$D001
		LOOP {
			ldy #3				; Copy @MOVETO+3 (XY) to @MOVETO (X)
			lda.a24.t XY
			sta.a24.t X

			inx.t
			inx.t
			inx.t
			cpx.t @MOVETO		; End the loop after copying to $D001
			IF (>) {
				BREAK
			}
		}

		dec @NPRM				; Decrement the count of parameters
		dec @IDX				; Decrement the shift counter
		IF (==) {				; Stop if done shifting
			BREAK
		}
	}

	RETURN
}
